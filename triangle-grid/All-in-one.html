<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Animations <3</title>
  <script defer type="text/javascript">
    /**
     * Starts a new Animation in #
     * @param ms interval the frames are rendered - milliseconds
     * @param npp (Nodes Per Pixel) a value of nodes created per pixel in the canvas. <br/>**< 0.0001 recommended!**
     * @param speed speed in px the nodes move per frame
     * @param range the range in with the struts are drawn
     * @param opacity the opacity added per frame (how fast the struts are disappearing)
     * @param color callback taking a value from 0 to 360 as the color of the strut
     * @returns id of renderer thread - use *clearInterval(<id>)* to stop
     */
    function startAnimation(
      ms = 100,
      npp = .00004,
      speed = 5,
      range = 200,
      opacity = .1,
      color = (node, nodeN) => { //just an example
        return Math.abs(Math.floor(Math.tanh(node.x - nodeN.x / node.y - nodeN.y) * 360)) + 50;
      }
    ) {
      const canvas = document.getElementById("animationCanvas");
      const ctx = canvas.getContext("2d");
      const height = window.innerHeight;
      const width = window.innerWidth;
      const nodes = [];

      canvas.addEventListener("click", () => canvas.requestFullscreen());

      function newNode() {
        return {
          x: Math.random() * width,
          y: Math.random() * height,
          angle: Math.random() * 360,
          color: Math.random() * 360
        };
      }

      const nodesNumber = Math.floor(height * width * npp);
      for (let i = 0; i < nodesNumber; i++) {
        nodes.push(newNode());
      }

      ctx.fillStyle = "rgb(0,9,9)";
      ctx.fillRect(0, 0, width, height);
      canvas.setAttribute("width", width.toString(10));
      canvas.setAttribute("height", height.toString(10));

      let intervals = [];
      intervals.push(setInterval(() => {
        ctx.fillStyle = `rgba(0,0,0,${opacity})`;
        ctx.fillRect(0, 0, width, height);
      }, ms));
      nodes.forEach((node, index) => {
        intervals.push(setInterval((node, index) => {
          //by filtering reducing drawing functions by 50% (performance)
          nodes.filter((nodeN, indexN) => index > indexN)
            .forEach((nodeN) => {

              const dx = node.x - nodeN.x;
              const dy = node.y - nodeN.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance <= range) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(nodeN.x, nodeN.y);
                //ctx.strokeStyle = correctColor(Math.abs(Math.floor(Math.tanh(dx / dy) * colorBandWidth)) + colorSet);
                ctx.strokeStyle = `hsla(${color(node, nodeN)}, 100%, 50%, ${Math.abs(distance / range - 1)})`;
                ctx.stroke();
              }
            });
        }, ms, node, index));
        intervals.push(setInterval(node => {
          if (node.x < 0 || node.y < 0
            || node.x > width || node.y > height) {
            //node.angle = correctAngle(node.angle + 90);
            node.x = Math.random() * width;
            node.y = Math.random() * height;
            node.angle = Math.random() * 360;
          }
          node.x += Math.cos(node.angle * (2 * Math.PI) / 360) * speed;
          node.y += Math.sin(node.angle * (2 * Math.PI) / 360) * speed;
        }, ms, node));
      });
      //separate function for parallel lines
      nodes.forEach(node => {
      });
      return intervals;
    }
  </script>
</head>
<body style="margin: 0; cursor: none;">
<canvas height="800" id="animationCanvas" style="background-color: black;" width="600"></canvas>
<script type="text/javascript">
  let getParams = {};
  window.location.search
    .substr(1)
    .split("&")
    .map(item => {
      return item.split("=");
    })
    .forEach(item => getParams[item[0]] = item[1] ? item[1] : "");

  //parse params to int/float
  getParams.type = getParams.type ? parseInt(getParams.type) : Math.floor(Math.random() * (2 + 1));
  getParams.one = getParams.one ? parseFloat(getParams.one) : Math.random();
  getParams.speed = getParams.speed ? parseInt(getParams.speed) : 100;
  getParams.npp = getParams.npp ? parseFloat(getParams.npp) / 1000 : .00004;
  getParams.range = getParams.range ? parseInt(getParams.range) : 200;
  getParams.distance = getParams.distance ? parseInt(getParams.distance) : 5;
  getParams.opacity = getParams.opacity ? parseFloat(getParams.opacity) : .1;

  const colorFunc = (node, nodeN) => {
    switch (getParams.type) {
      case 0:
        return (node.color + nodeN.color) / 2;
      case 1:
        return Math.abs(Math.floor(Math.tanh((node.x - nodeN.x) / (node.y - nodeN.y)) * 150)) + getParams.one * 360;
      case 2:
        switch (Math.floor(getParams.one * 3)) {
          case 0:
            return (node.y + nodeN.y) / 2 / window.innerHeight * 360;
          case 1:
            return (node.x + nodeN.x) / 2 / window.innerWidth * 360;
          case 2:
            return (node.x + node.y + nodeN.x + nodeN.y) / 2 / (window.innerWidth + window.innerHeight) * 360;
        }
    }
    return 100;
  };
  window.addEventListener("load", () => {
    if (getParams.noInfo !== "") {
      const text = [
        "type: " + getParams.type,
        "type: " + getParams.type + " | colorMix: " + Math.floor(getParams.one * 360),
        "type: " + getParams.type + " | schema: " +
        ((Math.floor(getParams.one * 3) === 0) ? "top-bottom" :
          (Math.floor(getParams.one * 3) === 1) ? "left-right" : "topLeft-bottomRight")
      ];
      const moreText =
        " | speed: " + getParams.speed +
        " | range: " + getParams.range +
        " | distance: " + getParams.distance +
        " | npp: " + getParams.npp * 1000 +
        " => " + Math.floor(window.innerHeight * window.innerWidth * getParams.npp) + " nodes" +
        " | opacity: " + getParams.opacity;
      document.getElementById("info").innerText =
        text[getParams.type] + (getParams.moreInfo === "" ? moreText : "");
    } else {
      document.getElementById("info").parentElement.outerHTML = "";
    }

    let gameIntervals;

    function newGame() {
      if (gameIntervals) gameIntervals.forEach(i => clearInterval(i));
      gameIntervals = startAnimation(getParams.speed, getParams.npp, getParams.distance, getParams.range, getParams.opacity, (node, nodeN) => {
        return colorFunc(node, nodeN);
      });
      console.log(gameIntervals);
    }

    window.addEventListener("resize", () => {
      newGame();
    });
    newGame();
  });
</script>
<div style="position: absolute; bottom: 10px; right: 10px;">
  <button id="info"></button>
  <button onclick="location.reload();">Reload</button>
</div>
</body>
</html>
