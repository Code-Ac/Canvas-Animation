<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Animations <3</title>
    <script defer type="text/javascript">
      /**
       * Starts a new Animation in #
       * @param ms interval the frames are rendered - milliseconds
       * @param npp (Nodes Per Pixel) a value of nodes created per pixel in the canvas. <br/>**< 0.0001 recommended!**
       * @param speed speed in px the nodes move per frame
       * @param range the range in with the struts are drawn
       * @param opacity the opacity added per frame (how fast the struts are disappearing)
       * @param color callback taking a value from 0 to 360 as the color of the strut
       * @returns id of renderer thread - use *clearInterval(<id>)* to stop
       */
      function startAnimation(
        ms = 100,
        npp = .000025,
        speed = 4,
        range = 200,
        opacity = .05,
        color = (node, nodeN) => { //just an example
          return Math.abs(Math.floor(Math.tanh(node.x - nodeN.x / node.y - nodeN.y) * 360)) + 50
        }
      ) {
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        const height = window.innerHeight;
        const width = window.innerWidth;
        const nodes = [];

        canvas.addEventListener('click', () => canvas.requestFullscreen());

        function newNode() {
          return {
            x: Math.random() * width,
            y: Math.random() * height,
            angle: Math.random() * 360,
            color: Math.random() * 360
          };
        }

        const nodesNumber = Math.floor(height * width * npp);
        for (let i = 0; i < nodesNumber; i++) {
          nodes.push(newNode());
        }

        ctx.fillStyle = 'rgb(0,0,0)';
        ctx.fillRect(0, 0, width, height);
        canvas.setAttribute('width', width.toString(10));
        canvas.setAttribute('height', height.toString(10));

        return setInterval(() => {
          ctx.fillStyle = `rgba(0,0,0,${opacity})`;
          ctx.fillRect(0, 0, width, height);
          nodes.forEach(node => {
            nodes.filter(nodeN => nodeN !== node).forEach(nodeN => {
              const dx = node.x - nodeN.x;
              const dy = node.y - nodeN.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance <= range) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(nodeN.x, nodeN.y);
                //const color = correctColor(Math.abs(Math.floor(Math.tanh(dx / dy) * colorBandWidth)) + colorSet);
                ctx.strokeStyle = `hsla(${color(node, nodeN)}, 100%, 50%, ${Math.abs(distance / range - 1)})`;
                ctx.stroke();
              }
            });
          });
          //separate function for parallel lines
          nodes.forEach(node => {
            if (node.x < 0 || node.y < 0
              || node.x > width || node.y > height) {
              //node.angle = correctAngle(node.angle + 90);
              node.x = Math.random() * width;
              node.y = Math.random() * height;
              node.angle = Math.random() * 360;
            }
            node.x += Math.cos(node.angle * (2 * Math.PI) / 360) * speed;
            node.y += Math.sin(node.angle * (2 * Math.PI) / 360) * speed;
          });
        }, ms);
      }
    </script>
</head>
<body style="margin: 0; cursor: none;">
<canvas height="800" id="animationCanvas" style="background-color: black;" width="600"></canvas>
<script type="text/javascript">
  let getParams = {};
  window.location.search
    .substr(1)
    .split('&')
    .map(item => {return item.split('=')})
    .forEach(item => getParams[item[0]] = item[1]);

  const random = {
    switch: getParams.type ? parseInt(getParams.type) : Math.floor(Math.random() * (2 + 1)),
    one: getParams.one ? parseFloat(getParams.one) : Math.random()
  }
  console.log(random);
  const colorFunc = (node, nodeN) => {
    switch (random.switch) {
      case 0:
        return (node.color + nodeN.color) / 2;
      case 1:
        return Math.abs(Math.floor(Math.tanh((node.x - nodeN.x) / (node.y - nodeN.y)) * 150)) + random.one * 360;
      case 2:
        switch (Math.floor(random.one * 3)) {
          case 0:
            return (node.y + nodeN.y) / 2 / window.innerHeight * 360;
          case 1:
            return (node.x + nodeN.x) / 2 / window.innerWidth * 360;
          case 2:
            return (node.x + node.y + nodeN.x + nodeN.y) / 2 / (window.innerWidth + window.innerHeight) * 360;
        }
    }
    return 100;
  }
  window.addEventListener('load', () => {
    const text = [
      'type: ' + random.switch,
      'type: ' + random.switch + ' | colorMix: ' + Math.floor(random.one * 360),
      'type: ' + random.switch + ' | schema: ' +
      ((Math.floor(random.one * 3) === 0) ? 'top-bottom' :
        (Math.floor(random.one * 3) === 1) ? 'left-right' : 'topLeft-bottomRight'),
    ]
    document.getElementById('info').innerText = text[random.switch];

    let gameId;

    function newGame() {
      if (gameId) clearInterval(gameId);
      gameId = startAnimation(100, .00004, 5, 200, .1, (node, nodeN) => {
        return colorFunc(node, nodeN);
      });
    }

    newGame();
    window.addEventListener('resize', () => {
      newGame();
    })
  });
</script>
<div style="position: absolute; bottom: 10px; right: 10px;">
    <button id="info"></button>
    <button onclick="location.reload();">Reload</button>
</div>
</body>
</html>
